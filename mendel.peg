{

const ast1 = global.ast1;

const namesBi = {
    '=': '__assign',
    '+=': '__assign_add',
    '-=': '__assign_sub',
    '|=': '__assign_or',
    '^=': '__assign_xor',
    '&=': '__assign_and',
    'or': '__or',
    'xor': '__xor',
    'and': '__and',
    '==': '__equal',
    '!=': '__not_equal',
    '<': '__less',
    '<=': '__less_equal',
    '>' : '__greater',
    '>=': '__greater_equal',
    'is': '__is',
    'in': '__in',
    '+': '__add',
    '-': '__sub',
    '|': '__bit_or',
    '^': '__bit_xor',
    '&': '__bit_and',
    '*': '__mul',
    '/': '__div',
    '%': '__mod',
    'shl': '__shl',
    'shr': '__shr',
    'rol': '__rol',
    'ror': '__ror',
};

const namesMono = {
    'not': '__not',
    '+': '__pos',
    '-': '__neg',
    '~': '__bit_not',
};

const flatten = (data) => {
    let result = [];

    const collect = (item) => {
        if (item instanceof Array) {
            for (const i in item) {
                collect(item[i]);
            }
        } else if (item !== null) {
            result.push(item);
        }
    };

    collect(data);

    return result;
};

const apply = (expr, actions) => {
    actions = flatten(actions);

    for (const i in actions) {
        expr = actions[i](expr);
    }

    return expr;
};

}

Root = stmts:(_ Stmt)* _ {
    stmts = flatten(stmts);

    return ast1.call(
        ast1.lookup('__do'),
        stmts
    );
}

Block = '{' _ root:Root _ '}' {
    return root;
}

Stmt = Func / If / While / Line

Func = $('func' _k) _ name:Name _ body:FuncBody {
    return ast1.call(
        ast1.lookup('__assign'),
        [
            ast1.symbol(name, 'const'),
            body,
        ]
    );
}

If = $('if' _k) _ '(' _ cond:Expr _ ')' _ body1:(Block / Stmt) body2:(
    _ $('else' _k) _ body:(Block / Stmt) {return body;}
)? {
    if (body2) {
        return ast1.call(
            ast1.lookup('__if_else'),
            [
                ast1.code(
                    ast1.lookup("__self"), [], [],
                    '',
                    cond
                ),
                ast1.code(
                    ast1.lookup("__self"), [], [],
                    '',
                    body1
                ),
                ast1.code(
                    ast1.lookup("__self"), [], [],
                    '',
                    body2
                ),
            ]
        );
    } else {
        return ast1.call(
            ast1.lookup('__if'),
            [
                ast1.code(
                    ast1.lookup("__self"), [], [],
                    '',
                    cond
                ),
                ast1.code(
                    ast1.lookup("__self"), [], [],
                    '',
                    body1
                ),
            ]
        );
    }
}

While = $('while' _k) _ '(' _ cond:Expr _ ')' _ body:(Block / Stmt) {
    return ast1.call(
        ast1.lookup('__while'),
        [
            ast1.code(
                ast1.lookup("__self"), [], [],
                '',
                cond
            ),
            ast1.code(
                ast1.lookup("__self"), [], [],
                '',
                body
            ),
        ]
    );
}

Line = expr:Expr _ ';' {
    return expr;
}

FuncBody = '(' params:(
    _ Param (_ ',' _ Param)* (_ ',' _ (Param / VA))? (_ ',')?
)? _ ')' extend:(
    _ $('extends' _k) _ '(' _ expr:Expr _ ')' {return expr;}
)? _ impl:(Block / Expr) {
    params = flatten(params);

    let paramNames = [];
    let paramModes = [];
    let vaMode = '';

    for (const i in params) {
        if (params[i].name === '...') {
            vaMode = params[i].mode;
        } else {
            paramNames.push(params[i].name);
            paramModes.push(params[i].mode);
        }
    }

    return ast1.code(
        extend || ast1.lookup('__self'),
        paramNames, paramModes, vaMode,
        impl
    );
}
Param = mode:Mode _ name:Name {
    return {
        name: name,
        mode: mode,
    };
} / name: Name {
    return {
        name: name,
        mode: 'const',
    };
}
VA = mode:Mode _ '...' {
    return {
        name: '...',
        mode: mode,
    };
} / '...' {
    return {
        name: '...',
        mode: 'const',
    };
}

Expr = Expr0

Expr0 = expr:Expr1 more:(_ More0)* {
    return apply(expr, more);
}
More0 = op:('=' / '+=' / '-=' / '|=' / '^=' / '&=') _ expr:Expr1 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr1 = expr:Expr2 more:((_ More1or)* / (_ More1xor)* / (_ More1and)*) {
    return apply(expr, more);
}
More1or = op:$('or' _k) _ expr:Expr2 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}
More1xor = op:$('xor' _k) _ expr:Expr2 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}
More1and = op:$('and' _k) _ expr:Expr2 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr2 = more:(More2 _)* expr:Expr3 {
    return apply(expr, more);
}
More2 = op:$('not' _k) {
    return (expr) => {
        return ast1.call(
            ast1.lookup(namesMono[op]),
            [expr]
        );
    };
}

Expr3 = expr:Expr4 more:(_ More3)* {
    return apply(expr, more);
}
More3 = op:(
    '==' / '!=' / '<' / '<=' / '>' / '>=' /
    $('is' _k) / $('in' _k)
) _ expr:Expr4 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr4 = Expr4a / Expr4b

Expr4a = expr:Expr5a more:(_ More4a)* {
    return apply(expr, more);
}
More4a = op:('+' / '-') _ expr:Expr5a {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr4b = expr:Expr5b more:((_ More4or)* / (_ More4xor)* / (_ More4and)*) {
    return apply(expr, more);
}
More4or = op:'|' _ expr:Expr5b {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}
More4xor = op:'^' _ expr:Expr5b {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}
More4and = op:'&' _ expr:Expr5b {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr5a = expr:Expr6 more:(_ More5a)* {
    return apply(expr, more);
}
More5a = op:('*' / '/' / '%') _ expr:Expr6 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr5b = expr:Expr6 more:(_ More5b)* {
    return apply(expr, more);
}
More5b = op:(
    $('shl' _k) / $('shr' _k) / $('rol' _k) / $('ror' _k)
) _ expr:Expr6 {
    return (oldExpr) => {
        return ast1.call(
            ast1.lookup(namesBi[op]),
            [oldExpr, expr]
        );
    };
}

Expr6 = more:(More6 _)* expr:ExprP {
    return apply(expr, more);
}
More6 = op:('+' / '-' / '~') {
    return (expr) => {
        return ast1.call(
            ast1.lookup(namesMono[op]),
            [expr]
        );
    };
}

ExprP = expr:(
    Bracket / Literal / Symbol / Lookup / Code
) actions:(
    _ Path / Call
)* {
    return apply(expr, actions);
}

Bracket = '(' _ expr:Expr _ ')' {
    return expr;
}

Literal = Number / String / Array / Map
Number = str:$(
    '0' [Xx] [0-9]+
) {
    return ast1.literal(parseInt(str, 16), 'unsigned');
} / str:$(
    ([0-9]+ '.' [0-9]* / [0-9]* '.' [0-9]+)
    ([Ee] ('+' / '-')? [0-9]+)? /
    [0-9]+ [Ee] ('+' / '-')? [0-9]+
) {
    return ast1.literal(parseFloat(str), 'float');
} / str:$(
    [0-9]+
) {
    return ast1.literal(parseInt(str, 10), 'int');
}
String = str:$(
    '\'' ([^'\\\r\n] / '\\' [^\r\n])* '\'' /
    '"' ([^"\\\r\n] / '\\' [^\r\n])* '"' // '
) {
    return ast1.literal(eval(str), 'string'); // TODO: remove eval
} / '`' raw:$([^`]*) '`' {
    return ast1.literal(raw, 'string');
}
Array = '???' { // TODO
}
Map = '???' { // TODO
}

Symbol = mode:Mode _ name:Name {
    return ast1.symbol(name, mode);
}

Lookup = name:Name {
    return ast1.lookup(name);
}

Code = $('func' _k) _ body:FuncBody {
    return body;
}

Path = '.' _ name:Name {
    return (upper) => {
        return ast1.path(upper, name);
    };
}

Call = '(' args:(
    _ Expr (_ ',' _ Expr)* (_ ',')?
)? _ ')' {
    args = flatten(args);

    return (callee) => {
        return ast1.call(callee, args);
    };
}

Name = str:$([A-Za-z_]+ [0-9A-Za-z_]*) {
    return str;
}

Mode = $('const' _k) / $('out' _k) / $('var' _k) / $('dep' _k) / $('ret' _k)

_k = ![0-9A-Za-z_] {
    return null;
}

_ = ('//' [^\r\n]* / [ \t\r\n])* {
    return null;
}
